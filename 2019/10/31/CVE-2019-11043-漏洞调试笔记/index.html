<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&family=Roboto+Serif:opsz,wght@8..144,100&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        梅子酒の笔记本
    </title>
    <link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
<link rel="alternate" href="/atom.xml" title="梅子酒の笔记本" type="application/atom+xml">
</head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            对PHP-FPM远程代码执行漏洞的分析（CVE-2019-11043 漏洞笔记）
        </p>
        <hr>
    </div>
    <div class="post-content heti">
        <blockquote>
<p>一篇发布极慢的分析笔记</p>
</blockquote>
<h1 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h1>
<p>这个漏洞在我看来是一个很经典的Web + 二进制的漏洞，在利用过程中，不仅需要二进制的基础来判断数据填充的长度，同样需要对Web方向内容的掌握。</p>
<p>由于之前对于二进制安全的学习都仅限于CTF，因此这是我第一次分析真实的二进制漏洞，会写的较为详细，希望能对同样在学习二进制的Web同学起到一些帮助。</p>
<p>整个漏洞利用的步骤可以分为两个步骤：</p>
<ol>
<li>利用空字节写覆盖结构体字段</li>
<li>伪造fastcgi_params完成RCE</li>
</ol>
<h1 id="1-寻找漏洞触发点"><a class="markdownIt-Anchor" href="#1-寻找漏洞触发点"></a> 1. 寻找漏洞触发点</h1>
<p>本地搭建好环境之后，gdb attach到php-fpm对应的进程上，当接受新请求并进行初始化时，会调用下述函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zend_first_try &#123;</span><br><span class="line">	<span class="keyword">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">char</span> *primary_script = <span class="literal">NULL</span>;</span><br><span class="line">		request_body_fd = <span class="number">-1</span>;</span><br><span class="line">		SG(server_context) = (<span class="keyword">void</span> *) request;</span><br><span class="line">		init_request_info();</span><br><span class="line"></span><br><span class="line">		fpm_request_info();</span><br><span class="line">		......</span><br></pre></td></tr></table></figure>
<p>跟入init_request_info，能发现init_request_info函数的作用是初始化request_info结构体，根据<a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a>的描述，结合github上的commit记录，不难分析出漏洞产生的大致位置：</p>
<p><img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/15726874714642.jpg" alt></p>
<p>而根据<a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a>上的描述能发现问题是出在path_info[0] = 0的后续操作上:</p>
<blockquote>
<p>the value of path_info[0] is set to zero (<a href="https://github.com/php/php-src/blob/master/sapi/fpm/fpm/fpm_main.c#L1150" target="_blank" rel="noopener">https://github.com/php/php-src/blob/master/sapi/fpm/fpm/fpm_main.c#L1150</a>); then FCGI_PUTENV is called. Using a carefully chosen length of the URL path and query string, an attacker can make path_info point precisely to the first byte of _fcgi_data_seg structure. Putting zero into it moves <code>char* pos</code> field backwards, and following FCGI_PUTENV overwrites some data (including other fast cgi variables) with the script path.</p>
</blockquote>
<h1 id="2-利用空字节写覆盖结构体字段"><a class="markdownIt-Anchor" href="#2-利用空字节写覆盖结构体字段"></a> 2. 利用空字节写覆盖结构体字段</h1>
<p>空字节写漏洞产生的位置在<code>/sapi/fpm/fpm/fpm_main.c</code>的1222行，这里一并截取1222行附近的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> old;</span><br><span class="line">FCGI_PUTENV(request, <span class="string">"ORIG_PATH_INFO"</span>, orig_path_info);</span><br><span class="line">old = path_info[<span class="number">0</span>];</span><br><span class="line">path_info[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!orig_script_name ||</span><br><span class="line">	<span class="built_in">strcmp</span>(orig_script_name, env_path_info) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (orig_script_name) &#123;</span><br><span class="line">		FCGI_PUTENV(request, <span class="string">"ORIG_SCRIPT_NAME"</span>, orig_script_name);</span><br><span class="line">	&#125;</span><br><span class="line">	SG(request_info).request_uri = FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_path_info);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	SG(request_info).request_uri = orig_script_name;</span><br><span class="line">&#125;</span><br><span class="line">path_info[<span class="number">0</span>] = old;</span><br></pre></td></tr></table></figure>
<h2 id="21-path_info-从何而来"><a class="markdownIt-Anchor" href="#21-path_info-从何而来"></a> 2.1 path_info 从何而来</h2>
<p>path_info变量的赋值是在<code>/sapi/fpm/fpm/fpm_main.c</code>的1206行开始的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *path_info;</span><br><span class="line"><span class="keyword">if</span> (apache_was_here) &#123;</span><br><span class="line">	<span class="comment">/* recall that PATH_INFO won't exist */</span></span><br><span class="line">	path_info = script_path_translated + ptlen;</span><br><span class="line">	tflag = (slen != <span class="number">0</span> &amp;&amp; (!orig_path_info || <span class="built_in">strcmp</span>(orig_path_info, path_info) != <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	path_info = env_path_info ? env_path_info + pilen - slen : <span class="literal">NULL</span>;</span><br><span class="line">	tflag = (orig_path_info != path_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>apache_was_here</code>这个变量在前面被设为了0，因此path_info的赋值语句实际上就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path_info = env_path_info ? env_path_info + pilen - slen : <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>env_path_info是从Fast CGI的PATH_INFO取过来的，而由于代入了<code>%0a</code>，在采取<code>fastcgi_split_path_info ^(.+?\.php)(/.*)$;</code>这样的Nginx配置项的情况下，fastcgi_split_path_info无法正确识别现在的url，因此会Path Info置空，所以env_path_info在进行取值时，同样会取到空值。变量传递关系如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FastCGI PATH_INFO  -&gt;  env_path_info  -&gt;  path_info</span><br></pre></td></tr></table></figure>
<p>回到path_info的赋值，此时已知env_path_info这个指针指向的内容为空，则path_info的实际赋值就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path_info = env_path_info + pilen - slen</span><br></pre></td></tr></table></figure>
<p>pilen、slen以及其他几个有关几个长度的变量的赋值流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">char</span> *env_path_translated = FCGI_GETENV(request, <span class="string">"PATH_TRANSLATED"</span>);</span><br><span class="line">...</span><br><span class="line">script_path_translated = env_path_translated;</span><br><span class="line">...</span><br><span class="line">script_path_translated_len = <span class="built_in">strlen</span>(script_path_translated)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">char</span> *pt = estrndup(script_path_translated, script_path_translated_len);</span><br><span class="line"><span class="keyword">int</span> len = script_path_translated_len;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> ptlen = <span class="built_in">strlen</span>(pt);</span><br><span class="line"><span class="keyword">int</span> slen = len - ptlen;      </span><br><span class="line"><span class="keyword">int</span> pilen = env_path_info ? <span class="built_in">strlen</span>(env_path_info) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tflag = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>简单来说，slen记录的是 <code>index.php</code> 到 <code>?</code>之间到长度，因此slen的大小是我们可以控制的。这也意味着我们通过控制slen的大小，去控制pilen - slen的大小，进而控制path_info向低地址取。</p>
<h2 id="22-空字节写"><a class="markdownIt-Anchor" href="#22-空字节写"></a> 2.2 空字节写</h2>
<p>空字节写的漏洞代码部分为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FCGI_PUTENV(request, <span class="string">"ORIG_PATH_INFO"</span>, orig_path_info);</span><br><span class="line">old = path_info[<span class="number">0</span>];</span><br><span class="line">path_info[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!orig_script_name ||</span><br><span class="line">	<span class="built_in">strcmp</span>(orig_script_name, env_path_info) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (orig_script_name) &#123;</span><br><span class="line">		FCGI_PUTENV(request, <span class="string">"ORIG_SCRIPT_NAME"</span>, orig_script_name);</span><br><span class="line">	&#125;</span><br><span class="line">	SG(request_info).request_uri = FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_path_info);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	SG(request_info).request_uri = orig_script_name;</span><br><span class="line">&#125;</span><br><span class="line">path_info[<span class="number">0</span>] = old;</span><br></pre></td></tr></table></figure>
<p>在第三行中对path_info指向的地址进行了空字节写，而最后又进行了恢复，因此漏洞利用部分只能通过<code>SG(request_info).request_uri = FCGI_PUTENV(request, &quot;SCRIPT_NAME&quot;, env_path_info);</code>或者<code>FCGI_PUTENV(request, &quot;ORIG_SCRIPT_NAME&quot;, orig_script_name);</code>来完成。</p>
<p>有关FCGI_PUTENV的函数组成如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_PUTENV(request, name, value) \</span></span><br><span class="line">	fcgi_quick_putenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>), value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_quick_putenv</span><span class="params">(fcgi_request *req, <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fcgi_hash_del(&amp;req-&gt;env, hash_value, var, var_len);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fcgi_hash_set(&amp;req-&gt;env, hash_value, var, var_len, val, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_set</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK;</span><br><span class="line">	fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (UNEXPECTED(p != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(p-&gt;hash_value == hash_value) &amp;&amp;</span><br><span class="line">		    p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			p-&gt;val_len = val_len;</span><br><span class="line">			p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line">			<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;buckets-&gt;idx &gt;= FCGI_HASH_TABLE_SIZE)) &#123;</span><br><span class="line">		fcgi_hash_buckets *b = (fcgi_hash_buckets*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_hash_buckets));</span><br><span class="line">		b-&gt;idx = <span class="number">0</span>;</span><br><span class="line">		b-&gt;next = h-&gt;buckets;</span><br><span class="line">		h-&gt;buckets = b;</span><br><span class="line">	&#125;</span><br><span class="line">	p = h-&gt;buckets-&gt;data + h-&gt;buckets-&gt;idx;</span><br><span class="line">	h-&gt;buckets-&gt;idx++;</span><br><span class="line">	p-&gt;next = h-&gt;hash_table[idx];</span><br><span class="line">	h-&gt;hash_table[idx] = p;</span><br><span class="line">	p-&gt;list_next = h-&gt;<span class="built_in">list</span>;</span><br><span class="line">	h-&gt;<span class="built_in">list</span> = p;</span><br><span class="line">	p-&gt;hash_value = hash_value;</span><br><span class="line">	p-&gt;var_len = var_len;</span><br><span class="line">	p-&gt;var = fcgi_hash_strndup(h, var, var_len);</span><br><span class="line">	p-&gt;val_len = val_len;</span><br><span class="line">	p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line">	<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里不难看出，FCGI_PUTENV实质上就是创建了一个新的fcgi_hash_bucket结构体。</p>
<p>接下来就会遇到另一个问题，往哪里写？我在调试这个漏洞的时候，一开始并未注意到需要覆盖pos字段的描述，因此在这里卡住了。</p>
<h2 id="23-为何要覆盖-pos"><a class="markdownIt-Anchor" href="#23-为何要覆盖-pos"></a> 2.3 为何要覆盖 pos</h2>
<p>在调试的过程中，通过对堆上数据的观察，不难发现各种PHP配置项是存储在堆上的，如图：<br>
<img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/15726804214613.jpg" alt></p>
<p>结合request.env.data的值可以发现pos实际存储的就是全局变量名的起始位置：<br>
<img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/ping-mu-kuai-zhao-20191102-shang-wu13321.png" alt><br>
<img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/ping-mu-kuai-zhao-20191102-xia-wu34058.png" alt></p>
<p>那么覆盖pos的原因就呼之欲出了：伪造全局变量。</p>
<h1 id="3-伪造fastcgi_params完成rce"><a class="markdownIt-Anchor" href="#3-伪造fastcgi_params完成rce"></a> 3. 伪造fastcgi_params完成RCE</h1>
<p>通过上一个小节的分析，可以知道漏洞需要通过FCGI_PUTENV进行触发，并且触发的过程会借用 path_info的空字节写来完成。那么具体该如何构造呢？</p>
<p>FastCGI本身是不支持http协议的，因此它在进行http协议数据的处理时，会首先将http header以及fastcgi_params的信息读取出来存储到request.env结构体中，如图所示：</p>
<p><img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/ping-mu-kuai-zhao-20191102-xia-wu114349.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_bXdlYi10ZXN0,color_f5eded,size_40,x_10,y_10" alt="屏幕快照 2019-11-02 下午11.43.49"></p>
<p>这也就意味着我们可以通过覆盖这些header来伪造fastcgi_params，这也是<a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a>这个exp能够RCE的原理。</p>
<h2 id="31-找到正确的偏移"><a class="markdownIt-Anchor" href="#31-找到正确的偏移"></a> 3.1 找到正确的偏移</h2>
<p>在实际覆盖的时候，我们是不知道具体会有哪些全局变量存放在env_path_info之前的，因此需要找到一个准确的偏移来进行覆盖。</p>
<p>在gdb中观察fcgi_data_seg这个结构体的pos与data的地址，可以发现，data字段与pos字段的距离为：</p>
<blockquote>
<p>0x562435b51fd8 - 0x562435b51fc0 = 24</p>
</blockquote>
<p><img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/02/15727100077512.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_bXdlYi10ZXN0,color_f5eded,size_40,x_10,y_10" alt></p>
<p>同时，来看一下fcgi_data_seg这个结构体是如何定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>                  *pos;</span><br><span class="line">	<span class="keyword">char</span>                  *end;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">char</span>                   data[<span class="number">1</span>];</span><br><span class="line">&#125; fcgi_data_seg;</span><br></pre></td></tr></table></figure>
<p>刚好就是 8 + 8 + 8 = 24，这与我们通过gdb观察到的地址偏移是一致的。</p>
<p>因此我们只需要让PATH_INFO成为data的首部数据，那么pos与PATH_INFO之间的偏移也就确定下来了，fcgi_data_seg结构的pos、end、next字段占24个字节，并且<code>PATH_INFO\x00</code>这个字符串占了10个字节，因此PATH_INFO的值到pos的偏移为34字节。</p>
<p>接下来就要寻找能让PATH_INFO置于fcgi_data_seg.data首部的方法。</p>
<p>PATH_INFO等全局变量是存放在堆上的，那么当前堆的大小被耗尽时，必然会malloc一块新的空间用于存放全局变量，那么这个过程中可以将我们的PATH_INFO放到fcgi_data_seg.data的首部吗？</p>
<p>为了解决这个问题，就需要来看下它是如何对内存进行操作的。</p>
<p>在对fcgi_hash进行赋值时，会调用函数fcgi_hash_strndup:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;end)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seg_size = (str_len + <span class="number">1</span> &gt; FCGI_HASH_SEG_SIZE) ? str_len + <span class="number">1</span> : FCGI_HASH_SEG_SIZE;</span><br><span class="line">		fcgi_data_seg *p = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + seg_size);</span><br><span class="line"></span><br><span class="line">		p-&gt;pos = p-&gt;data;</span><br><span class="line">		p-&gt;end = p-&gt;pos + seg_size;</span><br><span class="line">		p-&gt;next = h-&gt;data;</span><br><span class="line">		h-&gt;data = p;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = h-&gt;data-&gt;pos;</span><br><span class="line">	<span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">	ret[str_len] = <span class="number">0</span>;</span><br><span class="line">	h-&gt;data-&gt;pos += str_len + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码中不难发现，在进行赋值时，首先会进行大小的校验，当剩余空间不足时，会进行malloc。并且如果赋值的数据小于FCGI_HASH_SEG_SIZE时，会直接malloc大小为<code>sizeof(fcgi_data_seg) -1 + FCGI_HASH_SEG_SIZE</code>的一块空间。其中FCGI_HASH_SRG_SIZE的大小为4096，实际malloc的大小还要考虑十六字节的对齐，也就是将<code>4096 - 1 + 32</code>字节对齐，即:4128。</p>
<p>而提交的QUERY_STRING同样会存储到这块malloc的数据上，如果不断加长QUERY_STRING的长度，那么必然会导致这块数据被用完，然后malloc新的块。如果控制QUERY_STRING的大小使得刚好符合<code>h-&gt;data-&gt;pos + str_len + 1 &gt;= h-&gt;data-&gt;end</code>，那么在存储PATH_INFO时，会由于空间刚好被用完而导致malloc，而PATH_INFO则刚好会存储在该堆块的首部。</p>
<p>此时的内存布局就类似于：</p>
<p><img src="http://blog-pic-meizj.oss-cn-shanghai.aliyuncs.com/2019/11/04/15728512267140.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_bXdlYi10ZXN0,color_f5eded,size_40,x_10,y_10" alt></p>
<p>那么如何准确观测到<code>PATH_INFO位于fcgi_data_seg.data首部</code>这个现象呢？这就是原exp的牛逼之处了。</p>
<p>我们已经知道34个字节可以偏移到pos的首字节，那如果偏移量少几个字节呢？</p>
<p>pos字段存储的是一个地址，如果偏移少了几个字节，那么这个地址将会被修改，pos字段的地址有六个字节，那么将中间的一个字节改为<code>00</code>则必然会导致地址异常，这就是能使我们观测到<code>PATH_INFO位于fcgi_data_seg.data首部</code>这个现象。</p>
<p>考虑到我们需要在读pos指向的地址时，能读到我们控制的值，我们可以将它地址的最低字节改为00，那么修改后的地址与原地址的差异在 0xff-0x00 之间，我们可以通过插入无意义的header来填充这个差异。</p>
<h2 id="32-伪造php_value"><a class="markdownIt-Anchor" href="#32-伪造php_value"></a> 3.2 伪造PHP_VALUE</h2>
<p>在各种fastcgi_params中，我们最为熟悉的应该就是PHP_VALUE了，通过对PHP_VALUE的设置，可以很容易达到RCE。</p>
<p>当我们能够找到准确的偏移后，接下来要思考的就是如何伪造PHP_VALUE。伪造PHP_VALUE实质上就是想在FastCGI取fastcgi_params时取到我们伪造的值，而FastCGI取params的方式也是导致这次RCE的一个重要原因。</p>
<p>从之前gdb的数据以及结构体的定义中，不难发现在fcgi_hash_bucket的定义中使用到了哈希表。在哈希表中进行插入、读取数据时，会有一个计算哈希值的过程，计算得到的哈希值将决定插入/读取的数据的具体位置。有关于哈希表的更具体的内容，可以参见如下链接的内容：<a href="http://www.php-internals.com/book/?p=chapt03/03-01-01-hashtable" target="_blank" rel="noopener">《深入理解PHP内核》：哈希表(HashTable)</a></p>
<p>由于PHP是开源的，因此哈希计算函数也是已知的，在<a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a>所展示的exp中，便构造了一个header：EBUT，该header可以使得HTTP_EBUT与PHP_VALUE的哈希值是一样的。当然，在取值时还会校验变量名的长度等因素，具体过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">fcgi_hash_get</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK;</span><br><span class="line">	fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;hash_value == hash_value &amp;&amp;</span><br><span class="line">		    p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line">		    *val_len = p-&gt;val_len;</span><br><span class="line">		    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在fcgi_hash_strndup中通过memcpy来实现的复制，并且 <code>ret = h-&gt;data-&gt;pos;</code>，因此ret实际上指向的是00结尾一个地址。完整的思路就是：通过path_info修改pos，使其指向HTTP_EBUT的地址，随后借助memcpy让<code>PHP_VALUE\nsession.auto_start=1;;;</code>将<code>HTTP_EBUT\nmamku tvoyu</code>进行覆盖。</p>
<p>当读取PHP_VALUE时，会调用FCGI_GETENV:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ini = FCGI_GETENV(request, <span class="string">"PHP_VALUE"</span>);</span><br><span class="line"><span class="keyword">if</span> (ini) &#123;</span><br><span class="line">	<span class="keyword">int</span> mode = ZEND_INI_USER;</span><br><span class="line">	<span class="keyword">char</span> *tmp;</span><br><span class="line">	spprintf(&amp;tmp, <span class="number">0</span>, <span class="string">"%s\n"</span>, ini);</span><br><span class="line">	zend_parse_ini_string(tmp, <span class="number">1</span>, ZEND_INI_SCANNER_NORMAL, (<span class="keyword">zend_ini_parser_cb_t</span>)fastcgi_ini_parser, &amp;mode);</span><br><span class="line">	efree(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经说到，会首先计算<code>PHP_VALUE</code>的哈希值，确定idx，再根据idx去查找，此时就会查找到之前<code>HTTP_EBUT</code>的bucket，随后读取我们伪造的恶意val。</p>
<h1 id="4-reference"><a class="markdownIt-Anchor" href="#4-reference"></a> 4. Reference</h1>
<ul>
<li><a href="https://paper.seebug.org/1063/#_2" target="_blank" rel="noopener">PHP-fpm 远程代码执行漏洞(CVE-2019-11043)分析</a></li>
<li><a href="https://bithack.io/forum/639" target="_blank" rel="noopener">php-fpm RCE的POC的理解剖析(CVE-2019-11043)</a></li>
<li><a href="http://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html" target="_blank" rel="noopener">An analysis and thought about recently PHP-FPM RCE(CVE-2019-11043)</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt03/03-01-01-hashtable" target="_blank" rel="noopener">《深入理解PHP内核》：哈希表(HashTable)</a></li>
<li><a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a></li>
<li><a href="http://www.rai4over.cn/2019/10/25/php-fpm-Remote-Code-Execution-%E5%88%86%E6%9E%90-CVE-2019-11043/" target="_blank" rel="noopener">php-fpm Remote Code Execution 分析(CVE-2019-11043)</a></li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 Meizj.
        <!-- <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label> -->
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="white">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">
<script src="/libs/jquery.min.js"></script>
<script src="/libs/highlight/highlight.pack.js"></script>
<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script src="//unpkg.com/heti/umd/heti-addon.min.js"></script>
<script>
    const heti = new Heti('.heti');
    heti.autoSpacing();
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5JET59Z93Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5JET59Z93Q');
</script>
<script src="/js/js.js"></script>
<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>