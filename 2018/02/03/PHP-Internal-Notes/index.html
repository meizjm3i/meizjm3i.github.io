<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><title>笔记：PHP Internal [ 梅子酒の笔记本 ]</title><link rel="stylesheet" href="/css/meizj.css"><link rel="stylesheet" href="/css/prettify.css"><link rel="stylesheet" href="/css/tomorrow-night-blue.css"><script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script></head><body><div id="menu-outer"><nav id="menu-inner"><a id="menuLabel" href="/">Home</a><a id="menuLabel" href="/about">About</a><a id="menuLabel" href="/archives">Archives</a><a id="menuLabel" href="https://github.com/meizjm3i">Github</a></nav></div><div id="content-outer"><div id="content-inner"><div id="recent-posts"><a id="blogTitle">Meizj's Blog</a></div><article id="post"><h1 id="postTitle">笔记：PHP Internal</h1><h1 id="php的生命周期"><a class="markdownIt-Anchor" href="#php的生命周期"></a> PHP的生命周期</h1>
<p>PHP初期是作为单进程的CGI来运行的，因此不需要考虑线程安全问题。随着使用多线程模式的软件系统越来越多，php内核中形成了一个新的抽象层：TSRM（Thread Safe Resource Management）</p>
<h2 id="线程安全与非线程安全"><a class="markdownIt-Anchor" href="#线程安全与非线程安全"></a> 线程安全与非线程安全</h2>
<h3 id="thread-safe-data-pools"><a class="markdownIt-Anchor" href="#thread-safe-data-pools"></a> Thread-Safe Data Pools</h3>
<p>在扩展的module init过程中，扩展可以使用ts_allocate_id来申请资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sampleint;</span><br><span class="line">    <span class="keyword">char</span> *samplestring;</span><br><span class="line">&#125; php_sample_globals;</span><br><span class="line"><span class="keyword">int</span> sample_globals_id;</span><br><span class="line"> </span><br><span class="line">PHP_MINIT_FUNCTION(sample)</span><br><span class="line">&#123;</span><br><span class="line">    ts_allocate_id(&amp;sample_globals_id,</span><br><span class="line">        <span class="keyword">sizeof</span>(php_sample_globals),</span><br><span class="line">        (ts_allocate_ctor) php_sample_globals_ctor,</span><br><span class="line">        (ts_allocate_dtor) php_sample_globals_dtor);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但一个请求访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id返回的资源ID来获取偏移量。</p>
<h3 id="当不在线程环境时"><a class="markdownIt-Anchor" href="#当不在线程环境时"></a> 当不在线程环境时</h3>
<p>因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载。因此它比对应的非线程方式要慢一些（比如直接从真实的全局变量地址中取出数据）。</p>
<h3 id="访问全局变量"><a class="markdownIt-Anchor" href="#访问全局变量"></a> 访问全局变量</h3>
<p>在创建扩展时，标准文件包含集合中已经包含了条件定义的ZTS预处理标记。当PHP以线程安全方式构建时，这个值会被自动定义，只有在PHP以线程安全方式编译时，才会存在线程安全池。</p>
<h3 id="即使不需线程也要考虑线程"><a class="markdownIt-Anchor" href="#即使不需线程也要考虑线程"></a> 即使不需线程也要考虑线程</h3>
<p>正常的PHP构建默认是关闭线程安全的，只有在被构建的SAPI明确需要线程安全或者线程安全在./configure阶段显式的打开时，才会以线程安全方式构建。</p>
<p>当线程安全启用时，一个名为tsrm_ls的指针被增加到很多的内部函数原型中。这个指针允许PHP区分不同线程的数据。</p>
<p>在ZTS开启时，展开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_D     void ***tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_DC     , void ***tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_C     tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_CC     , tsrm_ls</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_myext_action</span><span class="params">(<span class="keyword">int</span> action_id, <span class="keyword">char</span> *message TSRMLS_DC)</span></span>;</span><br><span class="line">php_myext_action(<span class="number">42</span>, <span class="string">"The meaning of life"</span> TSRMLS_CC);</span><br></pre></td></tr></table></figure>
<p>可以看到，在非ZTS构建下，代码看到的是int,char * 。在ZTS构建下，原型则包括三个参数:int,char * ,void ***。</p>
<h1 id="php变量在内核中的实现"><a class="markdownIt-Anchor" href="#php变量在内核中的实现"></a> PHP变量在内核中的实现</h1>
<h2 id="21变量的类型"><a class="markdownIt-Anchor" href="#21变量的类型"></a> 2.1变量的类型</h2>
<p>PHP在内核中通过zval这个结构体来存储变量，它的定义在Zend/zend.h文件里，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zvalue_value value; <span class="comment">/* 变量的值 */</span></span><br><span class="line">    zend_uint refcount__gc;</span><br><span class="line">    zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></span><br><span class="line">    zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> <span class="title">zval</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//在Zend/zend_types.h里定义的：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> zend_uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> zend_uchar;</span><br></pre></td></tr></table></figure>
<p>zval里的refcout__gc是zend_unit类型，也就是unsigned int类型，is_ref__gc和type则是unsigned char型的。</p>
<p>保存变量值的value则是zvalue_value类型（php5），它是一个union，同样定义在了Zend/zend.h：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;</span><br><span class="line">    <span class="keyword">long</span> lval;  <span class="comment">/* long value */</span></span><br><span class="line">    <span class="keyword">double</span> dval;    <span class="comment">/* double value */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *val;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;  <span class="comment">/* hash table value */</span></span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>在这个基础上，PHP实现了八种数据类型：</p>
<ol>
<li>IS_NULL</li>
<li>IS_BOOL</li>
<li>IS_LONG</li>
<li>IS_DOUBLE</li>
<li>IS_STRING</li>
<li>IS_ARRAY</li>
<li>IS_OBJECT</li>
<li>IS_RESOURCE</li>
</ol>
<p>其中，要注意的是，对象除了存储复合数据以外，还需要保存：方法，访问权限，类常量以及其他的处理逻辑。</p>
<p>zval的type成员的值便是这八个之一。内核通过检测这个成员值来判断数据类型，如果要判断一个变量的类型，则读取type成员的值即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (foo-&gt;type == IS_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, foo-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然这种实现是正确的，但不建议这么做。</p>
</blockquote>
<p>PHP内核以后可能会修改变量的实现方式，因此检测type的方式以后可能会失效。为了解决这个问题，zend在头文件中定义了大量的宏，供我们检测、操纵变量。比如使用Z_TYPE_P()来改写上面那个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Z_TYPE_P(foo) == IS_NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, foo-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>php_printf()函数是php内核对printf函数的一层封装</p>
</blockquote>
<p>以_P结尾的宏的参数大多是* zval型变量。此外还有Z<br>
_TYPE和Z_TYPE_PP，前者是zval，后者是**zval。这三个宏的实现在Zend/zend_operations.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE(zval)        (zval).type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</span></span><br></pre></td></tr></table></figure>
<p>在以上知识的基础上，gettype的函数实现为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(gettype)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个arg间接指向就是我们传给gettype函数的参数。是一个zval**结构</span></span><br><span class="line">    <span class="comment">//所以我们要对他使用__PP后缀的宏。</span></span><br><span class="line">    zval **arg;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这个if的操作主要是让arg指向参数～</span></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"Z"</span>, &amp;arg) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></span><br><span class="line">    <span class="comment">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_PP(arg)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            RETVAL_STRING(<span class="string">"NULL"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> IS_BOOL:</span><br><span class="line">            RETVAL_STRING(<span class="string">"boolean"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">            RETVAL_STRING(<span class="string">"integer"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            RETVAL_STRING(<span class="string">"double"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            RETVAL_STRING(<span class="string">"string"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            RETVAL_STRING(<span class="string">"array"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            RETVAL_STRING(<span class="string">"object"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> *type_name;</span><br><span class="line">                type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class="line">                <span class="keyword">if</span> (type_name) &#123;</span><br><span class="line">                    RETVAL_STRING(<span class="string">"resource"</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            RETVAL_STRING(<span class="string">"unknown type"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22变量的值"><a class="markdownIt-Anchor" href="#22变量的值"></a> 2.2变量的值</h2>
<p>正如Z_TYPE_P此类宏一样，PHP内核同样提供了基础宏方便我们对变量的值进行操作。<br>
为了针对不同的数据类型进行操作，内核又定义了不同的宏，比如对IS_BOOL型的Z_BVAL，Z_BVAL_P，Z_BVAL_PP。针对IS_DOUBLE的Z_DVAL，Z_DVAL_P，Z_DVAL_PP。</p>
<p>ARRAY变量的值实质是存储在C语言的HashTable中的，我们可以用ARRAVAL组合宏(z_ARRVAL,Z_ARRVAL_P,Z_ARRVAL_PP)来访问数组的值。</p>
<p>有关值操作的宏定义都在Zend/zend_operations.h中。</p>
<h2 id="23创建php变量"><a class="markdownIt-Anchor" href="#23创建php变量"></a> 2.3创建PHP变量</h2>
<p>在创建PHP变量时，不直接使用C语言的malloc函数，而是使用宏MAKE_STD_ZVAL(pzv)，这个宏会申请一块地址赋给pzv，并初始化refcount和is_ref属性。</p>
<p>在申请完空间后，便可以对这个zval进行赋值操作。内核提供了以下宏供我们使用：</p>
<table>
<thead>
<tr>
<th>新宏</th>
<th style="text-align:right">其他宏的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZVAL_NULL(pvz); <strong>(注意这个Z和VAL之间没有下划线！)</strong></td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_NULL;<strong>(IS_NULL型不用赋值，因为这个类型只有一个值就是null，<sup>_</sup>)</strong></td>
</tr>
<tr>
<td>ZVAL_BOOL(pzv, b); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是b)</strong></td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_BOOL; Z_BVAL_P(pzv) = b ? 1 : 0;</td>
</tr>
<tr>
<td>ZVAL_TRUE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是true)</strong></td>
<td style="text-align:right">ZVAL_BOOL(pzv, 1);</td>
</tr>
<tr>
<td>ZVAL_FALSE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是false)</strong></td>
<td style="text-align:right">ZVAL_BOOL(pzv, 0);</td>
</tr>
<tr>
<td>ZVAL_LONG(pzv, l); <strong>(将pzv所指的zval设置为IS_LONG类型，值是l)</strong></td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_LONG;Z_LVAL_P(pzv) = l;</td>
</tr>
<tr>
<td>ZVAL_DOUBLE(pzv, d); <strong>(将pzv所指的zval设置为IS_DOUBLE类型，值是d)</strong></td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_DOUBLE;Z_DVAL_P(pzv) = d;</td>
</tr>
<tr>
<td>ZVAL_STRINGL(pzv,str,len,dup);<strong>(下面单独解释)</strong></td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_STRING;Z_STRLEN_P(pzv) = len;if (dup) {Z_STRVAL_P(pzv) =estrndup(str, len + 1);} else{Z_STRVAL_P(pzv)= str;}</td>
</tr>
<tr>
<td>ZVAL_STRING(pzv, str, dup);</td>
<td style="text-align:right">ZVAL_STRINGL(pzv, str,strlen(str), dup);</td>
</tr>
<tr>
<td>ZVAL_RESOURCE(pzv, res);</td>
<td style="text-align:right">Z_TYPE_P(pzv) = IS_RESOURCE;Z_RESVAL_P(pzv) = res;</td>
</tr>
</tbody>
</table>
<h2 id="24变量的存储方式"><a class="markdownIt-Anchor" href="#24变量的存储方式"></a> 2.4变量的存储方式</h2>
<p>在PHP中，用户在PHP中定义的变量我们都可以在一个HashTable中找到，当PHP中定义了一个变量，内核会自动把它的信息存储到一个用HashTable实现的符号表中。</p>
<p>全局作用域的符号表是在调用RINIT方法前创立的，并在RSHUTDOWN后销毁。</p>
<p>当用户在PHP中调用一个一个函数或者类的时候，内核会创建一个新的符号表并激活之，这也就是为什么我们无法在函数中使用函数外定义的变量的原因。</p>
<p>打开Zend/zend_globals.h文件，看一下_zend_execution_globals结构体，会在其中发现两个element：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_executor_globals</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    HashTable symbol_table;</span><br><span class="line">    HashTable *active_symbol_table;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，symbol_table元素可以通过EG宏访问，它代表着PHP的全局变量。active_symble_table则代表的是处于当前作用域的变量符号表。</p>
<p>以以下PHP代码作为实例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   $foo = <span class="string">"bar"</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在内核中的实现便是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	zval *fooval;</span><br><span class="line">	MAKE_STD_ZVAL(fooval);</span><br><span class="line">	ZVAL_STRING(fooval,<span class="string">"bar"</span>,<span class="number">1</span>);</span><br><span class="line">	ZEND_SET_SYMBOL(EG(active_symbol_table),<span class="string">"foo"</span>,fooval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即：先声明一个zval指针，并申请一块内存。再通过ZVAL_STRING将值设置为bar，最后一行的作用就是将这个zval加到当前的符号表中，并将其label设置定义成foo，这样便可以在代码里使用$foo.</p>
<h2 id="25变量的检索"><a class="markdownIt-Anchor" href="#25变量的检索"></a> 2.5变量的检索</h2>
<p>PHP内核中主要通过zend_hash_find函数来找到某个作用域下的用户已经定义好的变量.它是内核提供的操作HashTable的API之一.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    zval **fooval;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(</span><br><span class="line">            EG(active_symbol_table), <span class="comment">//这个参数是地址，如果我们操作全局作用域，则需要&amp;EG(symbol_table)</span></span><br><span class="line">            <span class="string">"foo"</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="string">"foo"</span>),</span><br><span class="line">            (<span class="keyword">void</span>**)&amp;fooval</span><br><span class="line">        ) == SUCCESS</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"成功发现$foo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"当前作用域下无法发现$foo."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashTable结构并不只是用于存储PHP语言里的变量，其他很多地方都在应用HashTable。一个HashTable有很多元素，在内核里叫做bucket。每个bucket的大小是固定的。如果想在bucket中存储数据，最好是先申请一块内存保存数据，然后在bucket中保存这个指针。</p>
<h2 id="26类型转换"><a class="markdownIt-Anchor" href="#26类型转换"></a> 2.6类型转换</h2>
<p>作为弱类型语言，类型转换是一个很不可忽视的方面，在内核中提供了许多函数用于实现类型转换，这一类函数有一个统一的形式:convert_to_*().</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将任意类型的zval转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_zval_to_string</span><span class="params">(zval *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    convert_to_string(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//其它基本的类型转换函数</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_long</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_double</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_null</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_boolean</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_array</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_object</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"> </span><br><span class="line">ZEND_API <span class="keyword">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class="line">\<span class="meta">#<span class="meta-keyword">define</span>   convert_to_string(op) <span class="meta-keyword">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC); &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-内存管理"><a class="markdownIt-Anchor" href="#3-内存管理"></a> 3 内存管理</h1>
<p>脚本语言和编译型语言最根本的区别可能就在内存管理上，现在越来越多的语言不允许用户直接操作内存，而是由虚拟机来负责内存的分配以及回收，如C#，Java，PHP等等。</p>
<h2 id="31-内存管理"><a class="markdownIt-Anchor" href="#31-内存管理"></a> 3.1 内存管理</h2>
<h3 id="free-the-mallocs"><a class="markdownIt-Anchor" href="#free-the-mallocs"></a> Free the Mallocs</h3>
<p>每个平台操作内存的方式都差不多是两个方面，一是负责申请，二是负责释放。如果一个内存块没有释放，并且所有者应用程序也永远不再使用它了，那么就称其为“内存泄漏”。小量，短时间的内存泄漏是无关紧要的，但是在使用Apache此类长时间运行的web服务器时，即使是小量的内存泄漏，累积多了也会使系统的资源消耗殆尽。</p>
<h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3>
<p>为了实现从用户端&quot;跳出&quot;，需要使用一种方法来完全”跳出“一个活动请求。这个功能是在内核中实现的：在一个请求的开始设置一个“跳出”地址，然后在任何die()或者exit()调用或在任何关键错误（E_ERROR）时执行一个longjmp()以跳转到该地址。<br>
以下是PHP中使用函数的使用原理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname, <span class="keyword">int</span> fname_len TSRMLS_DC)</span></span>&#123;</span><br><span class="line">    zend_function *fe;</span><br><span class="line">    <span class="keyword">char</span> *lcase_fname;</span><br><span class="line">    <span class="comment">/* php函数的名字是大小写不敏感的</span></span><br><span class="line"><span class="comment">     * 我们可以在function tables里找到他们</span></span><br><span class="line"><span class="comment">     * 保存的所有函数名都是小写的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcase_fname = estrndup(fname, fname_len);</span><br><span class="line">    zend_str_tolower(lcase_fname, fname_len);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(EG(function_table),lcase_fname, fname_len + <span class="number">1</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        zend_execute(fe-&gt;op_array TSRMLS_CC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;    </span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_ERROR,<span class="string">"Call to undefined function: %s()"</span>, fname);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(lcase_fname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当php_error_docref这个函数被调用时，便会触发内核中的错误处理机制，根据错误级别来决定是否调用longjmp来终止当前请求并退出call_function()，从而efree函数便永远不会执行。</p>
<p>其实php_error_docref()函数就相当于PHP语言里trigger_error()函数.它的第一个参数是一个将被添加到docref的可选的文档引用第三个参数可以是E_*家族常量，用于指示错误的严重程度。</p>
<h3 id="zend内存管理器"><a class="markdownIt-Anchor" href="#zend内存管理器"></a> Zend内存管理器</h3>
<p>在上面的“跳出”请求期间解决内存泄漏的方案之一是：使用Zend内存管理(Zend Merory Manager，简称ZendMM层、ZMM)层。内核的这一部分是非常类似于操作系统的内存管理功能–分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是“请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。就是说，它会隐式的释放所有的为该请求占用的内存。</p>
<p>除了提供隐式的内存清楚功能之外，ZendMM还能够根据php.ini中merory_limit设置来控制每一次内存请求行为。</p>
<h2 id="32-引用计数"><a class="markdownIt-Anchor" href="#32-引用计数"></a> 3.2 引用计数</h2>
<p>对于PHP这种需要同时处理多个请求的程序来说，申请和释放内存的时候应该慎之又慎。除了安全的申请和释放内存之外，还应该做到内存的最小化使用。</p>
<p>以下面的PHP代码为例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 'Hello World';</span><br><span class="line">$b = $a;</span><br><span class="line">unset($a);</span><br></pre></td></tr></table></figure>
<p>在这段代码中，先是对变量a赋值，再将a赋值给b，在PHP中，考虑到负载问题，PHP中的变量的名称和值在内核中是分开存放的，变量的名字a存放在符号表中，而值通过一个zval结构保存，而现在将a赋值给b则是让两者指向完全相同的内容。</p>
<p>先看一下其实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zval *helloval;</span><br><span class="line">MAKE_STD_ZVAL(helloval);</span><br><span class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>乍一看，当unset被调用时，会直接释放a的内存，如果不加以处理，便会引发逻辑错误。现在看一下zval的四个成员:<br>
value、type、is_ref__gc、refcount__gc。当一个变量被第一次创建时，refcount__gc成员被初始化为1，当这个变量被赋值给变量时，refcount__gc成员会变成2，因为此时有两个变量在使用这个zval结构。其实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zval *helloval;</span><br><span class="line">MAKE_STD_ZVAL(helloval);</span><br><span class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">ZVAL_ADDREF(helloval); <span class="comment">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>回到上面的php代码，对$aunset便是将对应的zval结构的refcount__gc的值变为1.</p>
<h3 id="写时复制机制"><a class="markdownIt-Anchor" href="#写时复制机制"></a> 写时复制机制</h3>
<p>当面对以下PHP代码时：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = $a;</span><br><span class="line">$b += <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出，我们希望执行后的a仍然为1，b为6，在refcount__gc大于1时，则为这个变化的变量从原zval结构复制一份新的zval出来，并改变其值。以下是其实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">zval *<span class="title">get_var_and_separate</span><span class="params">(<span class="keyword">char</span> *varname, <span class="keyword">int</span> varname_len TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval **varval, *varcopy;</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;varval) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果在符号表里找不到这个变量则直接return */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((*varval)-&gt;refcount &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></span><br><span class="line">        <span class="keyword">return</span> *varval;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 否则，复制一份zval*的值 */</span></span><br><span class="line">    MAKE_STD_ZVAL(varcopy);</span><br><span class="line">    varcopy = *varval;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 复制任何在zval*内已分配的结构*/</span></span><br><span class="line">    zval_copy_ctor(varcopy);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从符号表中删除原来的变量</span></span><br><span class="line"><span class="comment">     * 这将减少该过程中varval的refcount的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></span><br><span class="line">    varcopy-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    varcopy-&gt;is_ref = <span class="number">0</span>;</span><br><span class="line">    zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>,&amp;varcopy, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 返回新zval的地址 */</span></span><br><span class="line">    <span class="keyword">return</span> varcopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="change-on-write"><a class="markdownIt-Anchor" href="#change-on-write"></a> Change on Write</h3>
<p>在进行以下赋值时:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">$b += <span class="number">5</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，b是对a的引用，因此对b的更改会直接影响到a变量，也就无需上面那样再复制一份zval结构了。</p>
<p>而zval的is_ref__gc则是检测是否是一个用户在PHP语言中定义的引用。在执行第三条语句时，内核再次检查b变量的zval以确定是否需要复制一份新的zval结构。<br>
实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class="number">2</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> *varval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上这句，上面的get_var_and_separate才是完整的。</p>
<h1 id="4-动手编译php"><a class="markdownIt-Anchor" href="#4-动手编译php"></a> 4 动手编译PHP</h1>
<h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1</h2>
<p>之前说过，PHP编译前的configure有两个特殊的选项，对于开发扩展是很有帮助的</p>
<h3 id="enable-debug"><a class="markdownIt-Anchor" href="#enable-debug"></a> –enable-debug</h3>
<p>顾名思义，它的作用是激活调试模式。它将激活PHP源码中几个非常关键的函数，最典型的功能便是在每一个请求结束后给出这一次请求中内存的泄漏情况。</p>
<h3 id="enable-maintainer-zts"><a class="markdownIt-Anchor" href="#enable-maintainer-zts"></a> –enable-maintainer-zts</h3>
<p>第二个重要的参数便是激活php的线程安全机制(Thread Safe Resource Manager(TSRM)/Zend Thread Safety(ZTS))，使我们开发出的程序是线程安全的。对于TRSM的介绍大家可以参考第一章的介绍，在平时的开发中，建议打开这个选项。</p>
<h3 id="enable-embed"><a class="markdownIt-Anchor" href="#enable-embed"></a> –enable-embed</h3>
<p>其实还有一个选项比较重要，那就是enable-embed，它主要用在你做php的嵌入式开发的场景中。平时我们把php作为apache的一个module进行编译，<a href="http://xn--libphp5-5t0l790h.so" target="_blank" rel="noopener">得到libphp5.so</a>，而这个选项便使php编译后得到一个与我们设定的SAPI相对应的结果。</p>
</article><div id="paginator"></div></div></div><div id="footer"><div id="bottom-inner"><span>Powerd By </span><span> Meizj </span><span>using    </span><a href="https://github.com/meizjm3i/Meizj"><span>Meizj</span></a><span>.</span><br></div></div><script src="/js/prettify.js"></script><script>$(window).on('load', function(){ 
$('pre').addClass('prettyprint linenums');
prettyPrint();
});
$(".gutter").remove();</script></body></html>